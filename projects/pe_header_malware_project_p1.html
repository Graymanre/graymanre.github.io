<!DOCTYPE html>
<html lang="en">

<head>
    <meta property="og:title" content="GraymanRe - Understanding PE headers using malware" />
    <meta property="og:description" content="Understanding PE headers using malware" />
    <meta property="og:image" content="https://graymanre.github.io" />
    <meta property="og:url" content="https://graymanre.github.io/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@grayman_re" />

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>GraymanRe - Understanding PE headers using malware</title>

    <link rel="canonical" href="https://graymanre.github.io/">
    <link rel="alternate" type="application/rss+xml" title="GraymanRe" href="../feed.xml">
    <link rel="icon" type="image/x-icon" href="../img/favicon.ico">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

    <!-- Ionicons -->
    <link href="https://unpkg.com/ionicons@4.2.2/dist/css/ionicons.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../css/prism.css">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script>
        $(document).ready(function () {
            $('#header-content').load('https://graymanre.github.io/header.html', function () {
                $.getScript('/js/common.js');
            });
            $("#footer-content").load("https://graymanre.github.io/footer.html");
        });
    </script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4VZEKGVZPK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-4VZEKGVZPK');
    </script>
</head>

<body class="is-in">
    <!-- begin header -->
    <header class="header">
        <div id="header-content"></div>
    </header>
    <!-- end header -->
    <!-- begin search -->
    <div class="search">
        <div class="container">
            <div class="row">
                <div class="col col-12">
                    <div class="search__box">
                        <div class="search__group">
                            <div class="search__close">
                                <i class="ion ion-md-close"></i>
                            </div>
                            <label for="js-search-input" class="screen-reader-text">Search for Post</label>
                            <input type="text" id="js-search-input" class="search__text" autocomplete="off" placeholder="Type to search...">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="container">
            <div class="row search-results-list" id="js-results-container"></div>
        </div>
    </div>
    <!-- end search -->
    <!-- start of custom content -->
    <main class="content" aria-label="Content">
        <div class="post-head">
            <div class="container">
                <div class="row">
                    <div class="col col-2"></div>
                    <div class="col col-8 col-t-12">
                        <div class="post-head__box">
                            <div class="post__meta">
                                <span id="time"></span> min read <time class="post__date" datetime="2024-07-12T00:00:00+02:00">- 12 July 2024</time>
                            </div>
                            <h2 class="post__title">Understanding PE headers using malware</h2>
                            <div class="post__bottom">
                                <div class="post__author">
                                    <a href="../contact/" aria-label="GraymanRe">
                                        <img class="post__author-image"
                                             src="../img/logo.webp" alt="GraymanRe's Picture">
                                    </a>
                                </div>
                                <div class="post__bottom-meta">
                                    <a href="../contact/" class="post__author-link">GraymanRe</a>
                                    <span>in</span>
                                    <span class="post-tags">
                                        <a href="../projects" class="post__tag">Projects</a>
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- begin post -->
        <div class="container">
            <article id="article" class="post animate">
                <div class="post__content">
                    <h3 id="post__content__title">Introduction</h3>
                    <p>
                        This blog post is the first part of a 2-series blog post which aims to highlight my understanding of the headers within a PE-COFF
                        file and how they can be extracted as well as a demonstration of how PE headers are (ab)used in malware. 
                        <br>
                        To demonstrate both software development skills and the technical understanding of the PE-COFF file headers, a C++ tool will be
                        developed, aptly named PEDetect.
                        <br>
                        PEDetect is a self-made attempt at mirroring the features and capabilities of multiple well-known industry tools by aiming to
                        develop an advanced understanding of the PE-COFF file structure. With PEDetect the aim is to understand how these tools work, 
                        and more importantly how the PE-COFF and other headers in executables are structured. This understanding should lead to an 
                        increase in knowledge about the information that these headers contain and how they can be extracted and correlated. 
                        <br><br>
                        During the description of the PE file structure in this first blog post, the HxDSetup executable will be used to guide through 
                        the distinctive headers and structures. However, as this project is approached from the perspective of a malware reverse engineer,
                        we will test the compliance of the PE structure against a set of malware samples to discover the information rich environment that
                        is the PE file structure.
                        <br><br>
                        In the second part, we will aim at answering questions that reverse engineers try to answer when analyzing malicious malware samples.
                    </p>
                    <h3 id="post__content__title">Usage of PEDetect</h3>
                    <p>
                        For those, that would like to use PEDetect, I recommend following the steps below to compile the project and run it against 
                        executables. It is recommend that you use Visual Studio (for example VS Pro 2022) to build the project and execute the compiled
                        binary using the Visual Studio build tools. The output of this operation should be a working executable which takes one (1) 
                        command line argument: the PE-file whose headers should be analyzed.
                    </p>

                    <h3 id="post__content__title">Table of Contents</h3>
                    <div class="nav">
                        <a href="#section1" class="btn">1. Understanding the PE-COFF File Structure</a><br>
                        <a href="#section2" class="btn">2. DOS Header</a><br>
                        <a href="#section3" class="btn">3. DOS Stub</a><br>
                        <a href="#section4" class="btn">4. Rich Header</a><br>
                        <a href="#section5" class="btn">5. PE Header</a><br>
                        <a href="#section6" class="btn">6. COFF Header</a><br>
                        <a href="#section7" class="btn">7. Optional Header</a><br>
                        <a href="#section8" class="btn">8. Data Directories</a><br>
                        <a href="#section9" class="btn">9. Sections</a><br>
                        <a href="#section10" class="btn">10. Putting it all into action</a><br><br>
                    </div>

                    <h3 id="section1">Understanding the PE-COFF File Structure</h3>
                    <p>
                        PEDetect works by reading the input file byte by byte, starting at offset 0 and will obtain its information from the DOS Header 
                        and build upon this information to learn more about the subsequent headers: DOS Header, DOS Stub, COFF header, Optional Header,
                        Data Directory and sections. For those, wishing to follow along, the HxD installer will be used as the main example throughout
                        this blog.
                        <table>
                            <thead>
                                <tr>
                                    <td><b>Application Name</b></td>
                                    <td><b>SHA256</b></td>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>HxDSetup.exe</td>
                                    <td>DCCFA4B16AA79E273CC7FFC35493C495A7FD09F92A4B790F2DC41C65F64D5378) </td>
                                </tr>
                            </tbody>
                        </table>
                    </p>

                    <h3 id="section2">DOS Header</h3>
                    <p>
                        The DOS Header is the first header that you will encounter and should by default be 64 bytes long. It starts with the infamous 
                        magic bytes <span id="inline-code">MZ</span> or in hex <span id="inline-code">0x4D5A</span>. The header structure itself, is
                        defined in the <span id="inline-code">winnt.h</span> header file and appropriately named the 
                        <span id="inline-code">IMAGE_DOS_HEADER</span> struct.
                    </p>
                    <pre class="language-cpp"><code>
typedef struct _IMAGE_DOS_HEADER {      
    WORD   e_magic;                     // Magic number (MZ)
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of COFF header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
                    </code></pre><br>
                    <p>
                        Likely the most important field in the DOS header is the e_lfanew field, which contains the address of the COFF Header. PEDetect
                        will use the value in this field to determine where the COFF header is located and read from the header from the referenced 
                        address into memory. More about the COFF header later.
                    </p>
                    <div>
                        <img src="../img/dos_header.png" alt="DOS header" onclick="wi+ndow.open(this.src, '_blank');"
                             width="500" , height="500" onmouseover="this.style.cursor='zoom-in'" onmouseout="this.style.cursor='default'">
                    </div>
                    <br><br>

                    <h3 id="section3">DOS Stub</h3>
                    <p>
                        The DOS Stub is located directly after the DOS Header and is a piece of legacy 'code' which will print a default error message along
                        the lines of <span id="inline-code">This program cannot be run in DOS mode</span> or 
                        <span id="inline-code">This program must be run under Win32</span> if the executable is loaded in MS-DOS. In essence, the stub is
                        actually a piece of machine code which you can disassemble and analyze using a disassembler like GHIDRA/IDA. To do so, you copy 
                        the stub into a txt file and open it in your favorite disassembler. The DOS Stub is a 16-bit MS-DOS program native to Intel 8086
                        processors. Once loaded you will notice that it contains a few simple instructions along the lines of obtaining the address of
                        the error message and printing it using a DOS interrupt API call before exiting with an error.
                    </p>
                    <div>
                        <img src="../img/dos_stub.png" alt="DOS Stub" onclick="wi+ndow.open(this.src, '_blank');"
                             width="500" , height="500" onmouseover="this.style.cursor='zoom-in'" onmouseout="this.style.cursor='default'">
                    </div>
                    <br><br>

                    <h3 id="section4">RICH Header</h3>
                    <p>
                        Executables compiled using the Microsoft Visual Studio toolset will have a populated RICH header. The RICH header is an 
                        officially undocumented structure, however, over the years researchers have been able to 'decode' the specific items in this 
                        header. You will notice, that in the executable that we have used so far, the RICH header is fully nulled. Based on this, we can
                        conclude, as it is a benign executable, that the program was not build using the Microsoft Visual Studio toolset. Therefore, for
                        this example, we will use the output binary after compiling the PEDetect project. Since it is build using the Visual Studio 
                        toolset, the RICH header should be present.
                        <br><br>
                        The RICH header begins with a chunk of XOR-ed data, a signature and a 32-bit checksum which simultaneously acts as the XOR key.
                         Let's start with the most straight forward part, the signature: the signature is a 4-byte object containing the string
                         <span id="inline-code">Rich</span> (<span id="inline-code">0x52696368</span>).
                        <br><br>
                        The last part of the RICH Header, is a 32-bit checksum. This checksum is simultaneously the XOR key to decode the data before
                        the signature. Once decoded, the data will contain a signature containing the string <span id="inline-code">DanS</span>. 
                        Subsequently, there is likely to be padding in the form of zeroed DWORD values. Lastly, the data contains DWORD key-value pairs
                        which each represent a tool name, the build number of the tool and the number of times the tool has been used. PEDetect will 
                        read the XORed data blob into a fixed 88-byte array, it will then parse the signature to determine if a proper RICH header blob
                        has been read in. Subsequently, it will skip over the padding and parse every 8 bytes, corresponding to the DWORD key-value
                        pairs to decode the build number, tool number and count.
                    </p>
                    <div>
                        <img src="../img/rich_header.png" alt="RICH Header" onclick="wi+ndow.open(this.src, '_blank');"
                             width="500" , height="500" onmouseover="this.style.cursor='zoom-in'" onmouseout="this.style.cursor='default'">
                    </div>
                    <br><br>

                    <h3 id="section5">PE Header</h3>
                    <p>
                        Now we get to the PE Header. We previously obtained the starting address of this header in the DOS Header by reading the value 
                        located in the <span id="inline-code">e_lfanew</span> field. The COFF Header starts with the PE Signature, which simultaneously
                        marks the start of the PE file. The value is always <span id="inline-code">\x50\x45\x00\x00</span> and represents the ASCII 
                        string <span id="inline-code">PE\0\0</span>.
                    </p>
                    <div>
                        <img src="../img/pe_coffheader.png" alt="PE Header" onclick="wi+ndow.open(this.src, '_blank');"
                             width="500" , height="500" onmouseover="this.style.cursor='zoom-in'" onmouseout="this.style.cursor='default'">
                    </div>
                    <br><br>

                    <h3 id="section6">COFF Header</h3>
                    <p>
                        The COFF header contains 7 fields:
                    </p>
                    <table>
                        <thead>
                            <tr>
                                <th>Offset</th>
                                <th>Size</th>
                                <th>Field</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>0</td>
                                <td>2</td>
                                <td>Machine</td>
                                <td>The number identifying the type of target machine</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>2</td>
                                <td>NumberOfSections</td>
                                <td>
                                    The number of sections</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>4</td>
                                <td>TimeDateStamp</td>
                                <td>The number of seconds indicating when the file was created</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>4</td>
                                <td>PointerToSymbolTable</td>
                                <td>The file offset of the COFF symbol table</td>
                            </tr>
                            <tr>
                                <td>12</td>
                                <td>4</td>
                                <td>NumberOfSymbols</td>
                                <td>The number of entries in the symbol table</td>
                            </tr>
                            <tr>
                                <td>16</td>
                                <td>2</td>
                                <td>SizeOfOptionalHeader</td>
                                <td>The size of the optional header</td>
                            </tr>
                            <tr>
                                <td>18</td>
                                <td>2</td>
                                <td>Characteristics</td>
                                <td>The flags that indicate the attributes of the file</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>Machine</h4>
                    <p>
                        The first field is 2 bytes in size and the value represents the target architecture for which the executable was build. There's
                        a subset of predefined examples, such as:
                        <table>
                            <thead>
                                <tr>
                                    <td><b>Architecture in bytes</b></td>
                                    <td><b>Architecture representation</b></td>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>0x014C</td>
                                    <td>Intel 386</td>
                                </tr>
                                <tr>
                                    <td>0x01C0</td>
                                    <td>ARM</td>
                                </tr>
                                <tr>
                                    <td>0xAA64</td>
                                    <td>ARM64</td>
                                </tr>
                                <tr>
                                    <td>0x8664</td>
                                    <td>x64 (AMD64)</td>
                                </tr>
                            </tbody>
                        </table>
                    </p>
                    
                    <h4>NumberOfSections</h4>
                    <p>
                        Subsequently, the second field, once again 2 bytes in size, represents the number of sections that are present in the PE file. 
                        It will do so, by only counting the section headers, and not the full section. The sections, which we will dive into later, 
                        represent different parts of the file that contains code, data or other resources the executable requires.
                    </p>

                    <h4>TimeDateStamp</h4>
                    <p>
                        In the third field, 4 bytes in size, the timestamp, indicating when the file was build is present. This can be used in forensics
                        and malware reverse engineering cases. For example, it allows for speculation in regards to when certain campaigns were developed
                        and can be used to differentiate between samples and progressions in development of specific adverserial campaigns.
                    </p>

                    <h4>PointerToSymbolTable</h4>
                    <p>
                        The fourth field, 4 bytes in size, contains an address which points to the symbol table. However, note that this value, 
                        especially in executables and DLL files is often set to <span id="inline-code">0x00000000</span>.  Therefore, we will not
                        discuss this any further at this point.
                    </p>

                    <h4>NumberOfSymbols</h4>
                    <p>
                        The subsequent field, also 4 bytes in size, contains the number of symbols (entries) in the symbol table. As the symbol table
                        is often not present, this value is likely to be <span id="inline-code">0x00000000</span> as well.
                    </p>

                    <h4>SizeOfOptionalHeader</h4>
                    <p>
                        The sixth field, 2 bytes in size, contains the size of the Optional Header. There are only two possible values. If the executable
                        is a 32-bit executable, the value will likely be <span id="inline-code">0x00E0</span> - 224 bytes. In case of a 64-bit 
                        executable the value will likely be <span id="inline-code">0x00F0</span> - 240 bytes.
                    </p>

                    <h4>Characteristics</h4>
                    <p>
                        Ultimately, we end with the Characteristics field, which is 2 bytes in size. The Characteristics field is a combination of one
                        or multiple flags that indicate the attributes and characteristics of the executable. 
                        <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics">Microsoft has disclosed</a> the full 
                        list of Flags and their corresponding values and descriptions.
                    </p>

                    <h3 id="section7">Optional Header</h3>
                    <p>
                        Despite it's name, the optional header is present in every image filel and provides information to the loader. As defined by 
                        Microsoft, the optional header is only optional in object files. First step, is to valide that optional header magic number and
                        ensure our previous assumption in terms of 32-bit and 64-bit executables is correct.
                        <br>
                        Depending on the format, 32-bit or 64-bit, the Optional Header will have one more field. For 32-bit files, the BaseOfData field
                        exists, and doesn't exist in 64-bit executables. Furthermore, some fields might be 8 bytes in size instead of 4.
                    </p>
                    <table>
                        <thead>
                            <tr>
                                <th>Offset (PE/PE32+)</th>
                                <th>Size (PE/PE32+)</th>
                                <th>Field</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>0</td>
                                <td>2</td>
                                <td>Magic</td>
                                <td>Specifies file format</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>1</td>
                                <td>MajorLinkerVersion</td>
                                <td>The linker major version number</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>1</td>
                                <td>MinorLinkerVersion</td>
                                <td>The number of seconds indicating when the file was created</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>4</td>
                                <td>SizeOfCode</td>
                                <td>The size of the code (text) section(s)</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>4</td>
                                <td>SizeOfInitializedData</td>
                                <td>The size of the initialized data section(s) (BSS)</td>
                            </tr>
                            <tr>
                                <td>12</td>
                                <td>4</td>
                                <td>SizeOfUninitializedData</td>
                                <td>The size of the uninitialized data section(s) (BSS)</td>
                            </tr>
                            <tr>
                                <td>16</td>
                                <td>4</td>
                                <td>AddressOfEntryPoint</td>
                                <td>The address of the entry point relative to the image base when loaded into memory</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>4</td>
                                <td>BaseOfCode</td>
                                <td>The relative address of the beginning-of-code section</td>
                            </tr>
                            <tr>
                                <td>24</td>
                                <td>4</td>
                                <td>BaseOfData</td>
                                <td>The relative address of the beginning-of-data section, does not exist in PE32+ executables</td>
                            </tr>
                            <tr>
                                <td>28/24</td>
                                <td>4/8</td>
                                <td>ImageBase</td>
                                <td>The preferred address of the first byte of image when loaded into memory</td>
                            </tr>
                            <tr>
                                <td>32/32</td>
                                <td>4</td>
                                <td>SectionAlignment</td>
                                <td>The alignment in bytes of sections when they are loaded into memory</td>
                            </tr>   
                            <tr>
                                <td>36/36</td>
                                <td>4</td>
                                <td>FileAlignment</td>
                                <td>The alignment in bytes that is used to align the raw data of sections</td>
                            </tr>
                            <tr>
                                <td>40/40</td>
                                <td>2</td>
                                <td>MajorOperatingSystemVersion</td>
                                <td>The major version number of the required operating system</td>
                            </tr>   
                            <tr>
                                <td>42/42</td>
                                <td>2</td>
                                <td>MinorOperatingSystemVersion</td>
                                <td>The minor version number of the required operating system</td>
                            </tr>   
                            <tr>
                                <td>44/44</td>
                                <td>2</td>
                                <td>MajorImageVersion</td>
                                <td>The major version number of the image</td>
                            </tr>
                            <tr>
                                <td>46/46</td>
                                <td>2</td>
                                <td>MinorImageVersion</td>
                                <td>The minor version number of the image</td>
                            </tr>
                            <tr>
                                <td>48/48</td>
                                <td>2</td>
                                <td>MajorSubsystemVersion</td>
                                <td>The major version number of the subsystem</td>
                            </tr>
                            <tr>
                                <td>50/50</td>
                                <td>2</td>
                                <td>MinorSubsystemVersion</td>
                                <td>The minor version number of the subsystem</td>
                            </tr>
                            <tr>
                                <td>52/52</td>
                                <td>4</td>
                                <td>Win32VersionValue</td>
                                <td>Must be zero</td>
                            </tr>
                            <tr>
                                <td>56/56</td>
                                <td>4</td>
                                <td>SizeOfImage</td>
                                <td>The size (in bytes) of the image, including all headers, as the image is loaded in memory</td>
                            </tr>
                            <tr>
                                <td>60/60</td>
                                <td>4</td>
                                <td>SizeOfHeaders</td>
                                <td>The combined size of an MS-DOS stub, PE header and section headers</td>
                            </tr>
                            <tr>
                                <td>64/64</td>
                                <td>4</td>
                                <td>Checksum</td>
                                <td>The image file checksum, required for drivers or DLLs</td>
                            </tr>
                            <tr>
                                <td>68/68</td>
                                <td>2</td>
                                <td>Subsystem</td>
                                <td>The subsystem that is required to run this image</td>
                            </tr>
                            <tr>
                                <td>70/70</td>
                                <td>2</td>
                                <td>DllCharacteristics</td>
                                <td>The specific characteristics in case the image is a DLL</td>
                            </tr>
                            <tr>
                                <td>72/72</td>
                                <td>4/8</td>
                                <td>SizeOfStackReserve</td>
                                <td>The size of the stack to reserve</td>
                            </tr>
                            <tr>
                                <td>76/80</td>
                                <td>4/8</td>
                                <td>SizeOfStackCommit</td>
                                <td>The size of the stack to commit</td>
                            </tr>
                            <tr>
                                <td>80/88</td>
                                <td>4/8</td>
                                <td>SizeOfHeapReserve</td>
                                <td>The size of the heap to reserve</td>
                            </tr>
                            <tr>
                                <td>84/96</td>
                                <td>4/8</td>
                                <td>SizeOfHeapCommit</td>
                                <td>The size of the heap to commit</td>
                            </tr>
                            <tr>
                                <td>88/104</td>
                                <td>4</td>
                                <td>LoaderFlags</td>
                                <td>Reserved, must be zero</td>
                            </tr>
                            <tr>
                                <td>92/108</td>
                                <td>4</td>
                                <td>NumberOfRvaAndSizes</td>
                                <td>The number of data-directory entries in the remainder of the optional header</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>Magic</h4>
                    <p>
                        Like all headers so far, the Optional Header also starts with magic bytes. The magic is 2 bytes long and can be either one of
                        the following two values. If the value is <span id="inline-code">0x10B</span> it represents a 32-bit executable, if the value is
                        <span id="inline-code">0x20B</span> it represents a 64-bit executable.
                    </p>
                    
                    <h4>Major/MinorLinkerVersion</h4>
                    <p>
                        The bytes in these two fields make up the version number of the linker that generated the file and as such it indicates the 
                        compatability of the file with the linker software. These values combined can be used to determine the toolset which was used
                        to create the executable and contribute to assumptions about the programming language used.
                        <br>
                        An example value: <span id="inline-code">0x0E24</span> -> Microsoft Linker version 14.3 (corresponding to Visual Studio 2022)
                    </p>

                    <h4>SizeOfCode</h4>
                    <p>
                        This value represents the total size of all sections that contain executable code. As we will discuss sections later this is
                        all there's to this field for now.
                    </p>

                    <h4>SizeOf(Un)initializedData</h4>
                    <p>
                        These two fields represent the size of the initialized data section and the uninitialized data section (.bss).
                    </p>

                    <h4>AddressOfEntryPoint</h4>
                    <p>
                        The value in this field represents the Relative Virtual Address of the entrypoint function. This is the point where execution
                        starts after the program is loaded.
                    </p>

                    <h4>BaseOfCode</h4>
                    <p>
                        The value in this field represents the Relative Virtual Address of the start of the code section in memory
                    </p>

                    <h4>BaseOfData</h4>
                    <p>
                        The value in this field represents the Relative Virtual Address of the start of the data section in memory.
                    </p>
                    
                    <h4>ImageBase</h4>
                    <p>
                        The ImageBase represents the preferred memory address at which the image should be laded. In most cases the defaults for these
                        are <span id="inline-code">0x400000</span> for PE32 and <span id="inline-code">0x140000000</span> for PE32+. This should be 
                        familiar to those who have loaded images into disassemblers like GHIDRA/IDA and see addresses starting with 
                        <span id="inline-code">0x4...</span> or <span id="inline-code">0x14...</span> respectively.
                    </p>

                    <h4>Section/FileAlignment</h4>
                    <p>
                        The alignment of sections in memory and in the file on disk respectively.
                        <br>
                        Section: This value is typically set to <span id="inline-code">0x1000</span> representing 4KB. However, the value must always
                        be greater than or equal to the FileAlignment.
                        <br>
                        File: This value is typically set ot <span id="inline-code">0x200</span> (512 bytes) but can vary based on the file format.
                    </p>

                    <h4 id="os-section">Major/MinorOperatingSystemVersion</h4>
                    <p>
                        The version number corresponding to the minimum Windows OS version that is required to run the executable. Possible values
                        could be:
                        <ul>
                            <li>5.1 -> "Windows XP",</li>
                            <li>6.2 -> "Windows 8, Windows Server 2012",</li>
                            <li>10.0 -> "Windows 10/11, Windows Server 2016/2019/2022"</li>
                        </ul>
                    </p>

                    <h4>Major/MinorImageVersion</h4>
                    <p>
                        The major and minor version number of the image, this is set by the developer and as such can have any value.
                    </p>

                    <h4>Major/MinorSubsystemVersion</h4>
                    <p>
                        See <a href="#os-section" class="btn">Major/MinorOperatingSystemVersion</a>
                    </p>

                    <h4>Win32VersionValue</h4>
                    <p>
                        This value, by default, must be zero.
                    </p>

                    <h4>SizeOfHeaders</h4>
                    <p>
                        The value in this field contains the size of the MS-DOS stub, the PE Header and sections headers. Since we have already obtained
                        the MS-DOS stub and PE header, and therefore know its sizes, we can calculate the size of the section headers.
                    </p>

                    <h4>Checksum</h4>
                    <p>
                        The checksum value is a required field for kernel-mode drivers, whereas it is an optional field for user-mode executables. 
                        Therefore, it may often be an zeroed field in case of user-mode executables.
                    </p>

                    <h4>DllCharacteristics</h4>
                    <p>
                        The subsytem field determines which Windows subsystem (if any) is required to run the image. The full list of values and corresponding
                        descriptions can be found on the <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#windows-subsystem">Microsoft website</a>. 
                        <br>
                        Examples: 
                        <ul>
                            <li>0x02 -> Windows GUI,</li>
                            <li>0x03 -> Windows Console</li>
                        </ul>
                    </p>

                    <h4>SizeOf(Stack/Heap)(Commit/Reserve)</h4>
                    <p>
                        These values determine how the size of the memory that should be reserved and committed on both the heap and the stack. The
                        default size of the stack reserve is 1MB for PE32 and 4MB for PE32+.
                    </p>

                    <h4>LoaderFlags</h4>
                    <p>
                        This is a reserved field and must, by default, be zero.
                    </p>

                    <h4>NumberOfRvaAndSizes</h4>
                    <p>
                        The number of Data Directories that follow this field, and as such the OptionalHeader. By using the value in this field, we can
                        determine the size in bytes we have to read to capture all the fields of the Data Directory. Most often, the value of this field
                        is <span id="inline-code">0x10</span> or 16 which covers the standard PE directories like the Import and Export Tables and Import
                        Address Table.
                    </p>

                    <h3 id="section8">Data Directories</h3>
                    <p>
                        The data directory is a set of pointers that are part of the Optional Header.
                    </p>
                    <table>
                        <thead>
                            <tr>
                                <th>Offset (PE32/PE32+)</th>
                                <th>Size</th>
                                <th>Field name </th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>96/112</td>
                                <td>8</td>
                                <td>Export Table</td>
                                <td>The export table address and size (.edata section)</td>
                            </tr>
                            <tr>
                                <td>104/120</td>
                                <td>8</td>
                                <td>Import Table</td>
                                <td>The import table address and size (.idata section)</td>
                            </tr>
                            <tr>
                                <td>112/118</td>
                                <td>8</td>
                                <td>Resource Table</td>
                                <td>The resource table address and size (.rsrc section)</td>
                            </tr>
                            <tr>
                                <td>120/136</td>
                                <td>8</td>
                                <td>Exception Table</td>
                                <td>The exception table address and size (.pdata section)</td>
                            </tr>
                            <tr>
                                <td>128/144</td>
                                <td>8</td>
                                <td>Certificate Table</td>
                                <td>The certificate table address and size</td>
                            </tr>
                            <tr>
                                <td>136/152</td>
                                <td>8</td>
                                <td>Base Relocation Table</td>
                                <td>The base relocation table address and size (.reloc section)</td>
                            </tr>
                            <tr>
                                <td>144/160</td>
                                <td>8</td>
                                <td>Debug</td>
                                <td>The debug data starting address and size (.debug section)</td>
                            </tr>
                            <tr>
                                <td>152/168</td>
                                <td>8</td>
                                <td>Architecture</td>
                                <td>Reserved, must be zero</td>
                            </tr>
                            <tr>
                                <td>160/176</td>
                                <td>8</td>
                                <td>Global Ptr</td>
                                <td>The RVA of the value to be stored in the global pointer register</td>
                            </tr>
                            <tr>
                                <td>168/184</td>
                                <td>8</td>
                                <td>TLS Table</td>
                                <td>The thread local storage table address and size (.tls section)</td>
                            </tr>
                            <tr>
                                <td>176/192</td>
                                <td>8</td>
                                <td>Load Config Table</td>
                                <td>The load configuration table address and size</td>
                            </tr>
                            <tr>
                                <td>184/208</td>
                                <td>8</td>
                                <td>Bound Import</td>
                                <td>The bound import table address and size</td>
                            </tr>
                            <tr>
                                <td>192/208</td>
                                <td>8</td>
                                <td>Import Address Table</td>
                                <td>The import address table address and size</td>
                            </tr>
                            <tr>
                                <td>200/216</td>
                                <td>8</td>
                                <td>Delay Import Descriptor</td>
                                <td>The delay import descriptor address and size</td>
                            </tr>
                            <tr>
                                <td>208/224</td>
                                <td>8</td>
                                <td>CLR Runtime Header</td>
                                <td>The CLR runtime header address and size (.cormeta section)</td>
                            </tr>
                            <tr>
                                <td>216/232</td>
                                <td>8</td>
                                <td>Not specified</td>
                                <td>Reserved, must be zero</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>
                        For each field in the Data Directory, the first four bytes represent the Relative Virtual Address pointing ot the start of each
                        table. Whereas the last four bytes represent the size of the table.
                    </p>

                    <h3 id="section9">Sections</h3>
                    <p>
                        We saw in the Data Directories that most tables correspond to a specific section. A section in a PE file contains code or data
                        that linkers and Microsoft Win32 loaders process without special knowledge of the section contents.
                    </p>
                    <div>
                        <img src="../img/sections.png" alt="sections" onclick="wi+ndow.open(this.src, '_blank');"
                             width="500" , height="500" onmouseover="this.style.cursor='zoom-in'" onmouseout="this.style.cursor='default'">
                    </div>
                    <p>
                        Each section, is 40 bytes long and contains the 10 fields outlined below:
                    </p>
                    <table>
                        <thead>
                            <tr>
                                <th>Offset</th>
                                <th>Size</th>
                                <th>Field name</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>0</td>
                                <td>8</td>
                                <td>Name</td>
                                <td>An ASCII string representing the section name</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>4</td>
                                <td>VirtualSize</td>
                                <td>The total size of the section in memory. Note that a section may be larger than the size on disk due to alignment</td>
                            </tr>
                            <tr>
                                <td>12</td>
                                <td>4</td>
                                <td>VirtualAddress</td>
                                <td>The RVA of the section, relative to the image base</td>
                            </tr>
                            <tr>
                                <td>16</td>
                                <td>4</td>
                                <td>SizeOfRawData</td>
                                <td>The size of the section data in the file, aligned to the File Alignment</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>4</td>
                                <td>PointerToRawData</td>
                                <td>The file offset where the section's data starts</td>
                            </tr>
                            <tr>
                                <td>24</td>
                                <td>4</td>
                                <td>PointerToRelocations</td>
                                <td>The file offset of the relocation entries for the section</td>
                            </tr>
                            <tr>
                                <td>28</td>
                                <td>4</td>
                                <td>PointerToLinenumbers</td>
                                <td>The file offset of the line number entries for the section</td>
                            </tr>
                            <tr>
                                <td>32</td>
                                <td>2</td>
                                <td>NumberOfRelocations</td>
                                <td>The number of relocation entries for the section</td>
                            </tr>
                            <tr>
                                <td>34</td>
                                <td>2</td>
                                <td>NumberOfLinenumbers</td>
                                <td>The number of line number entries for the section</td>
                            </tr>
                            <tr>
                                <td>36</td>
                                <td>4</td>
                                <td>Characteristics</td>
                                <td>Flags indicating attributes for the section</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3 id="section10">Putting it all into action</h3>
                    <p>
                        
                    </p>
                </div>
            </article>
        </div>
        <!-- end post -->
    </main>
    <!-- end of custom content -->

    <div class="top" title="Top"><i class="ion ion-ios-arrow-up"></i></div>
    <!-- begin footer-widgets -->
    <section class="footer-widgets">
        <div class="container">
            <div class="row">
                <div class="col col-4 col-d-6 col-t-12">
                    <div class="widget widget-tag-cloud">
                        <div class="widget__head">
                            <h3 class="widget__title">Explore Tags</h3>
                        </div>
                        <div class="tag__cloud">
                            <a href="../re" class="set-1">Reverse Engineering</a>
                            <a href="../projects" class="set-1">Projects</a>
                            <a href="../ctf/" class="set-5">CTF Writeups</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>
    <!-- end footer-widgets -->
    <!-- begin footer -->
    <footer class="footer">
        <div id="footer-content"></div>
    </footer>
    <!-- end footer -->
    <script src="../js/vendors/jquery-3.5.1.min.js"></script>
    <script src="../js/vendors/simple-jekyll-search.min.js"></script>
    <script src="../js/vendors/jquery.fitvids.js"></script>
    <script src="../js/vendors/lazyload.min.js"></script>
    <script src="../js/vendors/transition.js"></script>
    <script src="../js/vendors/zoom.min.js"></script>
    <script src="../js/vendors/prism.js"></script>
    <script src="../js/common.js"></script>
    <script src="../js/readingtime.js"></script>

    <script>
        var base_url = "",
            pagination_next_url = base_url + '/page2',
            pagination_next_page_number = '',
            pagination_available_pages_number = '1';
    </script>
</body>

</html>